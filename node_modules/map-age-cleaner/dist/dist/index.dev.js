"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var p_defer_1 = __importDefault(require("p-defer"));

function mapAgeCleaner(map) {
  var _this = this;

  var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'maxAge';
  var processingKey;
  var processingTimer;
  var processingDeferred;

  var cleanup = function cleanup() {
    return __awaiter(_this, void 0, void 0,
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2() {
      var _this2 = this;

      var setupTimer, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(processingKey !== undefined)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              setupTimer = function setupTimer(item) {
                return __awaiter(_this2, void 0, void 0,
                /*#__PURE__*/
                regeneratorRuntime.mark(function _callee() {
                  var delay;
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          processingDeferred = p_defer_1["default"]();
                          delay = item[1][property] - Date.now();

                          if (!(delay <= 0)) {
                            _context.next = 6;
                            break;
                          }

                          // Remove the item immediately if the delay is equal to or below 0
                          map["delete"](item[0]);
                          processingDeferred.resolve();
                          return _context.abrupt("return");

                        case 6:
                          // Keep track of the current processed key
                          processingKey = item[0];
                          processingTimer = setTimeout(function () {
                            // Remove the item when the timeout fires
                            map["delete"](item[0]);

                            if (processingDeferred) {
                              processingDeferred.resolve();
                            }
                          }, delay); // tslint:disable-next-line:strict-type-predicates

                          if (typeof processingTimer.unref === 'function') {
                            // Don't hold up the process from exiting
                            processingTimer.unref();
                          }

                          return _context.abrupt("return", processingDeferred.promise);

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));
              };

              _context2.prev = 3;
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context2.prev = 7;
              _iterator = map[Symbol.iterator]();

            case 9:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context2.next = 16;
                break;
              }

              entry = _step.value;
              _context2.next = 13;
              return setupTimer(entry);

            case 13:
              _iteratorNormalCompletion = true;
              _context2.next = 9;
              break;

            case 16:
              _context2.next = 22;
              break;

            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context2.t0;

            case 22:
              _context2.prev = 22;
              _context2.prev = 23;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 25:
              _context2.prev = 25;

              if (!_didIteratorError) {
                _context2.next = 28;
                break;
              }

              throw _iteratorError;

            case 28:
              return _context2.finish(25);

            case 29:
              return _context2.finish(22);

            case 30:
              _context2.next = 34;
              break;

            case 32:
              _context2.prev = 32;
              _context2.t1 = _context2["catch"](3);

            case 34:
              processingKey = undefined;

            case 35:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[3, 32], [7, 18, 22, 30], [23,, 25, 29]]);
    }));
  };

  var reset = function reset() {
    processingKey = undefined;

    if (processingTimer !== undefined) {
      clearTimeout(processingTimer);
      processingTimer = undefined;
    }

    if (processingDeferred !== undefined) {
      // tslint:disable-line:early-exit
      processingDeferred.reject(undefined);
      processingDeferred = undefined;
    }
  };

  var originalSet = map.set.bind(map);

  map.set = function (key, value) {
    if (map.has(key)) {
      // If the key already exist, remove it so we can add it back at the end of the map.
      map["delete"](key);
    } // Call the original `map.set`


    var result = originalSet(key, value); // If we are already processing a key and the key added is the current processed key, stop processing it

    if (processingKey && processingKey === key) {
      reset();
    } // Always run the cleanup method in case it wasn't started yet


    cleanup(); // tslint:disable-line:no-floating-promises

    return result;
  };

  cleanup(); // tslint:disable-line:no-floating-promises

  return map;
}

exports["default"] = mapAgeCleaner; // Add support for CJS

module.exports = mapAgeCleaner;
module.exports["default"] = mapAgeCleaner;