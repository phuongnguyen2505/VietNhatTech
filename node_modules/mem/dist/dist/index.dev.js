'use strict';

var mimicFn = require("mimic-fn");

var mapAgeCleaner = require("map-age-cleaner");

var decoratorInstanceMap = new WeakMap();
var cacheStore = new WeakMap();
/**
[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.

@param fn - Function to be memoized.

@example
```
import mem = require('mem');

let i = 0;
const counter = () => ++i;
const memoized = mem(counter);

memoized('foo');
//=> 1

// Cached as it's the same arguments
memoized('foo');
//=> 1

// Not cached anymore as the arguments changed
memoized('bar');
//=> 2

memoized('bar');
//=> 2
```
*/

var mem = function mem(fn) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      cacheKey = _ref.cacheKey,
      _ref$cache = _ref.cache,
      cache = _ref$cache === void 0 ? new Map() : _ref$cache,
      maxAge = _ref.maxAge;

  if (typeof maxAge === 'number') {
    // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5
    // @ts-expect-error
    mapAgeCleaner(cache);
  }

  var memoized = function memoized() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var key = cacheKey ? cacheKey(arguments_) : arguments_[0];
    var cacheItem = cache.get(key);

    if (cacheItem) {
      return cacheItem.data;
    }

    var result = fn.apply(this, arguments_);
    cache.set(key, {
      data: result,
      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY
    });
    return result;
  };

  mimicFn(memoized, fn, {
    ignoreNonConfigurable: true
  });
  cacheStore.set(memoized, cache);
  return memoized;
};
/**
@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.

@example
```
import mem = require('mem');

class Example {
    index = 0

    @mem.decorator()
    counter() {
        return ++this.index;
    }
}

class ExampleWithOptions {
    index = 0

    @mem.decorator({maxAge: 1000})
    counter() {
        return ++this.index;
    }
}
```
*/


mem.decorator = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (target, propertyKey, descriptor) {
    var input = target[propertyKey];

    if (typeof input !== 'function') {
      throw new TypeError('The decorated value must be a function');
    }

    delete descriptor.value;
    delete descriptor.writable;

    descriptor.get = function () {
      if (!decoratorInstanceMap.has(this)) {
        var value = mem(input, options);
        decoratorInstanceMap.set(this, value);
        return value;
      }

      return decoratorInstanceMap.get(this);
    };
  };
};
/**
Clear all cached data of a memoized function.

@param fn - Memoized function.
*/


mem.clear = function (fn) {
  var cache = cacheStore.get(fn);

  if (!cache) {
    throw new TypeError('Can\'t clear a function that was not memoized!');
  }

  if (typeof cache.clear !== 'function') {
    throw new TypeError('The cache Map can\'t be cleared!');
  }

  cache.clear();
};

module.exports = mem;