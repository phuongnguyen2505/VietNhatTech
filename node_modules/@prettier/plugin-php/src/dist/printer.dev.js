"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require$doc$builders = require("prettier").doc.builders,
    breakParent = _require$doc$builders.breakParent,
    join = _require$doc$builders.join,
    line = _require$doc$builders.line,
    lineSuffix = _require$doc$builders.lineSuffix,
    group = _require$doc$builders.group,
    conditionalGroup = _require$doc$builders.conditionalGroup,
    indent = _require$doc$builders.indent,
    dedent = _require$doc$builders.dedent,
    ifBreak = _require$doc$builders.ifBreak,
    hardline = _require$doc$builders.hardline,
    softline = _require$doc$builders.softline,
    literalline = _require$doc$builders.literalline,
    align = _require$doc$builders.align,
    dedentToRoot = _require$doc$builders.dedentToRoot;

var willBreak = require("prettier").doc.utils.willBreak;

var _require$util = require("prettier").util,
    isNextLineEmptyAfterIndex = _require$util.isNextLineEmptyAfterIndex,
    hasNewline = _require$util.hasNewline,
    hasNewlineInRange = _require$util.hasNewlineInRange;

var comments = require("./comments");

var pathNeedsParens = require("./needs-parens");

var _require = require("./util"),
    getLast = _require.getLast,
    getPenultimate = _require.getPenultimate,
    isLastStatement = _require.isLastStatement,
    lineShouldEndWithSemicolon = _require.lineShouldEndWithSemicolon,
    printNumber = _require.printNumber,
    shouldFlatten = _require.shouldFlatten,
    maybeStripLeadingSlashFromUse = _require.maybeStripLeadingSlashFromUse,
    fileShouldEndWithHardline = _require.fileShouldEndWithHardline,
    hasDanglingComments = _require.hasDanglingComments,
    hasLeadingComment = _require.hasLeadingComment,
    hasTrailingComment = _require.hasTrailingComment,
    docShouldHaveTrailingNewline = _require.docShouldHaveTrailingNewline,
    isLookupNode = _require.isLookupNode,
    isFirstChildrenInlineNode = _require.isFirstChildrenInlineNode,
    shouldPrintHardLineAfterStartInControlStructure = _require.shouldPrintHardLineAfterStartInControlStructure,
    shouldPrintHardLineBeforeEndInControlStructure = _require.shouldPrintHardLineBeforeEndInControlStructure,
    getAlignment = _require.getAlignment,
    isProgramLikeNode = _require.isProgramLikeNode,
    getNodeKindIncludingLogical = _require.getNodeKindIncludingLogical,
    useDoubleQuote = _require.useDoubleQuote,
    hasEmptyBody = _require.hasEmptyBody,
    isNextLineEmptyAfterNamespace = _require.isNextLineEmptyAfterNamespace,
    shouldPrintHardlineBeforeTrailingComma = _require.shouldPrintHardlineBeforeTrailingComma,
    isDocNode = _require.isDocNode,
    getAncestorNode = _require.getAncestorNode,
    isReferenceLikeNode = _require.isReferenceLikeNode,
    getNextNode = _require.getNextNode,
    normalizeMagicMethodName = _require.normalizeMagicMethodName,
    getNextNonSpaceNonCommentCharacterIndex = _require.getNextNonSpaceNonCommentCharacterIndex,
    isNextLineEmpty = _require.isNextLineEmpty;

function isMinVersion(actualVersion, requiredVersion) {
  return parseFloat(actualVersion) >= parseFloat(requiredVersion);
}

function shouldPrintComma(options, requiredVersion) {
  if (!options.trailingCommaPHP) {
    return false;
  }

  return isMinVersion(options.phpVersion, requiredVersion);
}

function shouldPrintHardlineForOpenBrace(options) {
  switch (options.braceStyle) {
    case "1tbs":
      return false;

    case "psr-2":
    case "per-cs":
    default:
      return true;
  }
}

function genericPrint(path, options, print) {
  var node = path.getValue();

  if (!node) {
    return "";
  } else if (typeof node === "string") {
    return node;
  }

  var printedWithoutParens = printNode(path, options, print);
  var parts = [];
  var needsParens = pathNeedsParens(path, options);

  if (needsParens) {
    parts.unshift("(");
  }

  parts.push(printedWithoutParens);

  if (needsParens) {
    parts.push(")");
  }

  if (lineShouldEndWithSemicolon(path)) {
    parts.push(";");
  }

  if (fileShouldEndWithHardline(path)) {
    parts.push(hardline);
  }

  return parts;
}

function printPropertyLookup(path, options, print) {
  var nullsafe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return [nullsafe ? "?" : "", "->", path.call(print, "offset")];
}

function printNullsafePropertyLookup(path, options, print) {
  return printPropertyLookup(path, options, print, true);
}

function printStaticLookup(path, options, print) {
  var node = path.getValue();
  var needCurly = !["variable", "identifier"].includes(node.offset.kind);
  return ["::", needCurly ? "{" : "", path.call(print, "offset"), needCurly ? "}" : ""];
}

function printOffsetLookup(path, options, print) {
  var node = path.getValue();
  var shouldInline = node.offset && node.offset.kind === "number" || getAncestorNode(path, "encapsed");
  return ["[", node.offset ? group([indent([shouldInline ? "" : softline, path.call(print, "offset")]), shouldInline ? "" : softline]) : "", "]"];
} // We detect calls on member expressions specially to format a
// common pattern better. The pattern we are looking for is this:
//
// $arr
//   ->map(function(x) { return $x + 1; })
//   ->filter(function(x) { return $x > 10; })
//   ->some(function(x) { return $x % 2; });
//
// The way it is structured in the AST is via a nested sequence of
// propertylookup, staticlookup, offsetlookup and call.
// We need to traverse the AST and make groups out of it
// to print it in the desired way.


function printMemberChain(path, options, print) {
  // The first phase is to linearize the AST by traversing it down.
  //
  // Example:
  //   a()->b->c()->d();
  // has the AST structure
  //   call (isLookupNode d (
  //     call (isLookupNode c (
  //       isLookupNode b (
  //         call (variable a)
  //       )
  //     ))
  //   ))
  // and we transform it into (notice the reversed order)
  //   [identifier a, call, isLookupNode b, isLookupNode c, call,
  //    isLookupNode d, call]
  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or
  // the first group whether it is in parentheses or not
  //
  // Example:
  //   $a
  //     ->call()
  //
  //     ->otherCall();
  //
  //   ($foo ? $a : $b)
  //     ->call()
  //     ->otherCall();

  function shouldInsertEmptyLineAfter(node) {
    var originalText = options.originalText;
    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);
    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty
    // line after that parenthesis

    if (nextChar === ")") {
      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);
    }

    return isNextLineEmpty(originalText, node, options);
  }

  function traverse(path) {
    var node = path.getValue();

    if (node.kind === "call" && (isLookupNode(node.what) || node.what.kind === "call")) {
      printedNodes.unshift({
        node: node,
        printed: [comments.printAllComments(path, function () {
          return printArgumentsList(path, options, print);
        }, options), shouldInsertEmptyLineAfter(node) ? hardline : ""]
      });
      path.call(function (what) {
        return traverse(what);
      }, "what");
    } else if (isLookupNode(node)) {
      // Print *lookup nodes as we standard print them outside member chain
      var printedMemberish = null;

      if (node.kind === "propertylookup") {
        printedMemberish = printPropertyLookup(path, options, print);
      } else if (node.kind === "nullsafepropertylookup") {
        printedMemberish = printNullsafePropertyLookup(path, options, print);
      } else if (node.kind === "staticlookup") {
        printedMemberish = printStaticLookup(path, options, print);
      } else {
        printedMemberish = printOffsetLookup(path, options, print);
      }

      printedNodes.unshift({
        node: node,
        needsParens: pathNeedsParens(path, options),
        printed: comments.printAllComments(path, function () {
          return printedMemberish;
        }, options)
      });
      path.call(function (what) {
        return traverse(what);
      }, "what");
    } else {
      printedNodes.unshift({
        node: node,
        printed: path.call(print)
      });
    }
  }

  var node = path.getValue();
  printedNodes.unshift({
    node: node,
    printed: printArgumentsList(path, options, print)
  });
  path.call(function (what) {
    return traverse(what);
  }, "what"); // Restore parens around `propertylookup` and `staticlookup` nodes with call.
  // $value = ($object->foo)();
  // $value = ($object::$foo)();

  for (var _i = 0; _i < printedNodes.length; ++_i) {
    if (printedNodes[_i].node.kind === "call" && printedNodes[_i - 1] && ["propertylookup", "nullsafepropertylookup", "staticlookup"].includes(printedNodes[_i - 1].node.kind) && printedNodes[_i - 1].needsParens) {
      printedNodes[0].printed = ["(", printedNodes[0].printed];
      printedNodes[_i - 1].printed = [printedNodes[_i - 1].printed, ")"];
    }
  } // create groups from list of nodes, i.e.
  //   [identifier a, call, isLookupNode b, isLookupNode c, call,
  //    isLookupNode d, call]
  // will be grouped as
  //   [
  //     [identifier a, Call],
  //     [isLookupNode b, isLookupNode c, call],
  //     [isLookupNode d, call]
  //   ]
  // so that we can print it as
  //   a()
  //     ->b->c()
  //     ->d();


  var groups = [];
  var currentGroup = [printedNodes[0]];
  var i = 1;

  for (; i < printedNodes.length; ++i) {
    if (printedNodes[i].node.kind === "call" || isLookupNode(printedNodes[i].node) && printedNodes[i].node.offset && printedNodes[i].node.offset.kind === "number") {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }

  if (printedNodes[0].node.kind !== "call") {
    for (; i + 1 < printedNodes.length; ++i) {
      if (isLookupNode(printedNodes[i].node) && isLookupNode(printedNodes[i + 1].node)) {
        currentGroup.push(printedNodes[i]);
      } else {
        break;
      }
    }
  }

  groups.push(currentGroup);
  currentGroup = []; // Then, each following group is a sequence of propertylookup followed by
  // a sequence of call. To compute it, we keep adding things to the
  // group until we have seen a call in the past and reach a
  // propertylookup

  var hasSeenCallExpression = false;

  for (; i < printedNodes.length; ++i) {
    if (hasSeenCallExpression && isLookupNode(printedNodes[i].node)) {
      // [0] should be appended at the end of the group instead of the
      // beginning of the next one
      if (printedNodes[i].node.kind === "offsetlookup" && printedNodes[i].node.offset && printedNodes[i].node.offset.kind === "number") {
        currentGroup.push(printedNodes[i]);
        continue;
      }

      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }

    if (printedNodes[i].node.kind === "call") {
      hasSeenCallExpression = true;
    }

    currentGroup.push(printedNodes[i]);

    if (printedNodes[i].node.comments && comments.hasTrailingComment(printedNodes[i].node)) {
      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }
  }

  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  } // Merge next nodes when:
  //
  // 1. We have `$this` variable before
  //
  // Example:
  //     $this->method()->property;
  //
  // 2. When we have offsetlookup after *lookup node
  //
  // Example:
  //    $foo->Data['key']("foo")
  //      ->method();
  //
  // 3. expression statements with variable names shorter than the tab width
  //
  // Example:
  // $foo->bar()
  //     ->baz()
  //     ->buzz()


  function shouldNotWrap(groups) {
    var hasComputed = groups[1].length && groups[1][0].node.kind === "offsetlookup";

    if (groups[0].length === 1) {
      var firstNode = groups[0][0].node;
      return firstNode.kind === "variable" && (firstNode.name === "this" || isExpressionStatement && isShort(firstNode.name)) || isReferenceLikeNode(firstNode);
    }

    function isShort(name) {
      return name.length < options.tabWidth;
    }

    var lastNode = getLast(groups[0]).node;
    return isLookupNode(lastNode) && (lastNode.offset.kind === "identifier" || lastNode.offset.kind === "variable") && hasComputed;
  }

  var isExpressionStatement = path.getParentNode().kind === "expressionstatement";
  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);

  function printGroup(printedGroup) {
    var result = [];

    for (var _i2 = 0; _i2 < printedGroup.length; _i2++) {
      // Checks if the next node (i.e. the parent node) needs parens
      // and print accordingl y
      if (printedGroup[_i2 + 1] && printedGroup[_i2 + 1].needsParens) {
        result.push("(", printedGroup[_i2].printed, printedGroup[_i2 + 1].printed, ")");
        _i2++;
      } else {
        result.push(printedGroup[_i2].printed);
      }
    }

    return result;
  }

  function printIndentedGroup(groups) {
    if (groups.length === 0) {
      return "";
    }

    return indent(group([hardline, join(hardline, groups.map(printGroup))]));
  }

  var printedGroups = groups.map(printGroup);
  var oneLine = printedGroups; // Indicates how many we should merge
  //
  // Example (true):
  //   $this->method()->otherMethod(
  //     'argument'
  //   );
  //
  // Example (false):
  //   $foo
  //     ->method()
  //     ->otherMethod();

  var cutoff = shouldMerge ? 3 : 2;
  var flatGroups = groups.slice(0, cutoff).flat();
  var hasComment = flatGroups.slice(1, -1).some(function (node) {
    return comments.hasLeadingComment(node.node);
  }) || flatGroups.slice(0, -1).some(function (node) {
    return comments.hasTrailingComment(node.node);
  }) || groups[cutoff] && comments.hasLeadingComment(groups[cutoff][0].node);
  var hasEncapsedAncestor = getAncestorNode(path, "encapsed"); // If we only have a single `->`, we shouldn't do anything fancy and just
  // render everything concatenated together.
  // In `encapsed` node we always print in one line.

  if (groups.length <= cutoff && !hasComment || hasEncapsedAncestor) {
    return group(oneLine);
  } // Find out the last node in the first group and check if it has an
  // empty line after


  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;
  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.kind !== "call" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
  var expanded = [printGroup(groups[0]), shouldMerge ? groups.slice(1, 2).map(printGroup) : "", shouldHaveEmptyLineBeforeIndent ? hardline : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))];
  var callExpressionCount = printedNodes.filter(function (tuple) {
    return tuple.node.kind === "call";
  }).length; // We don't want to print in one line if there's:
  //  * A comment.
  //  * 3 or more chained calls.
  //  * Any group but the last one has a hard line.
  // If the last group is a function it's okay to inline if it fits.

  if (hasComment || callExpressionCount >= 3 || printedGroups.slice(0, -1).some(willBreak)) {
    return group(expanded);
  }

  return [// We only need to check `oneLine` because if `expanded` is chosen
  // that means that the parent group has already been broken
  // naturally
  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : "", conditionalGroup([oneLine, expanded])];
}

function couldGroupArg(arg) {
  return arg.kind === "array" && (arg.items.length > 0 || arg.comments) || arg.kind === "function" || arg.kind === "method" || arg.kind === "closure";
}

function shouldGroupLastArg(args) {
  var lastArg = getLast(args);
  var penultimateArg = getPenultimate(args);
  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,
  // disable last element expansion.
  !penultimateArg || penultimateArg.kind !== lastArg.kind);
}

function shouldGroupFirstArg(args) {
  if (args.length !== 2) {
    return false;
  }

  var _args = _slicedToArray(args, 2),
      firstArg = _args[0],
      secondArg = _args[1];

  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.kind === "function" || firstArg.kind === "method" || firstArg.kind === "closure") && secondArg.kind !== "retif" && !couldGroupArg(secondArg);
}

function printArgumentsList(path, options, print) {
  var argumentsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "arguments";
  var args = path.getValue()[argumentsKey];

  if (args.length === 0) {
    return ["(", comments.printDanglingComments(path, options,
    /* sameIndent */
    true), ")"];
  }

  var anyArgEmptyLine = false;
  var hasEmptyLineFollowingFirstArg = false;
  var lastArgIndex = args.length - 1;
  var printedArguments = path.map(function (argPath, index) {
    var arg = argPath.getNode();
    var parts = [print(argPath)];

    if (index === lastArgIndex) {// do nothing
    } else if (isNextLineEmpty(options.originalText, arg, options)) {
      if (index === 0) {
        hasEmptyLineFollowingFirstArg = true;
      }

      anyArgEmptyLine = true;
      parts.push(",", hardline, hardline);
    } else {
      parts.push(",", line);
    }

    return parts;
  }, argumentsKey);
  var node = path.getValue();
  var lastArg = getLast(args);
  var maybeTrailingComma = shouldPrintComma(options, "7.3") && ["call", "new", "unset", "isset"].includes(node.kind) || shouldPrintComma(options, "8.0") && ["function", "closure", "method", "arrowfunc", "attribute"].includes(node.kind) ? indent([lastArg && shouldPrintHardlineBeforeTrailingComma(lastArg) ? hardline : "", ","]) : "";

  function allArgsBrokenOut() {
    return group(["(", indent([line].concat(_toConsumableArray(printedArguments))), maybeTrailingComma, line, ")"], {
      shouldBreak: true
    });
  }

  var shouldGroupFirst = shouldGroupFirstArg(args);
  var shouldGroupLast = shouldGroupLastArg(args);

  if (shouldGroupFirst || shouldGroupLast) {
    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag

    var printedExpanded;
    var i = 0;
    path.each(function (argPath) {
      if (shouldGroupFirst && i === 0) {
        printedExpanded = [argPath.call(function (p) {
          return print(p, {
            expandFirstArg: true
          });
        }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : "", printedArguments.slice(1)];
      }

      if (shouldGroupLast && i === args.length - 1) {
        printedExpanded = [].concat(_toConsumableArray(printedArguments.slice(0, -1)), [argPath.call(function (p) {
          return print(p, {
            expandLastArg: true
          });
        })]);
      }

      i++;
    }, argumentsKey);
    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);
    var simpleConcat = ["("].concat(_toConsumableArray(printedExpanded), [")"]);
    return [somePrintedArgumentsWillBreak ? breakParent : "", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? ["(", group(printedExpanded[0], {
      shouldBreak: true
    })].concat(_toConsumableArray(printedExpanded.slice(1)), [")"]) : ["("].concat(_toConsumableArray(printedArguments.slice(0, -1)), [group(getLast(printedExpanded), {
      shouldBreak: true
    }), ")"]), group(["(", indent([line].concat(_toConsumableArray(printedArguments))), ifBreak(maybeTrailingComma), line, ")"], {
      shouldBreak: true
    })], {
      shouldBreak: shouldBreak
    })];
  }

  return group(["(", indent([softline].concat(_toConsumableArray(printedArguments))), ifBreak(maybeTrailingComma), softline, ")"], {
    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine
  });
}

function shouldInlineRetifFalseExpression(node) {
  return node.kind === "array" && node.items.length !== 0;
}

function shouldInlineLogicalExpression(node) {
  return node.right.kind === "array" && node.right.items.length !== 0;
} // For binary expressions to be consistent, we need to group
// subsequent operators with the same precedence level under a single
// group. Otherwise they will be nested such that some of them break
// onto new lines but not all. Operators with the same precedence
// level should either all break or not. Because we group them by
// precedence level and the AST is structured based on precedence
// level, things are naturally broken up correctly, i.e. `&&` is
// broken before `+`.


function printBinaryExpression(path, print, options, isNested, isInsideParenthesis) {
  var parts = [];
  var node = path.getValue();

  if (node.kind === "bin") {
    // Put all operators with the same precedence level in the same
    // group. The reason we only need to do this with the `left`
    // expression is because given an expression like `1 + 2 - 3`, it
    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
    // is where the rest of the expression will exist. Binary
    // expressions on the right side mean they have a difference
    // precedence level and should be treated as a separate group, so
    // print them normally. (This doesn't hold for the `**` operator,
    // which is unique in that it is right-associative.)
    if (shouldFlatten(node.type, node.left.type)) {
      // Flatten them out by recursively calling this function.
      parts = parts.concat(path.call(function (left) {
        return printBinaryExpression(left, print, options,
        /* isNested */
        true, isInsideParenthesis);
      }, "left"));
    } else {
      parts.push(path.call(print, "left"));
    }

    var shouldInline = shouldInlineLogicalExpression(node);
    var right = shouldInline ? [node.type, " ", path.call(print, "right")] : [node.type, line, path.call(print, "right")]; // If there's only a single binary expression, we want to create a group
    // in order to avoid having a small right part like -1 be on its own line.

    var parent = path.getParentNode();
    var shouldGroup = !(isInsideParenthesis && ["||", "&&"].includes(node.type)) && getNodeKindIncludingLogical(parent) !== getNodeKindIncludingLogical(node) && getNodeKindIncludingLogical(node.left) !== getNodeKindIncludingLogical(node) && getNodeKindIncludingLogical(node.right) !== getNodeKindIncludingLogical(node);
    var shouldNotHaveWhitespace = isDocNode(node.left) || node.left.kind === "bin" && isDocNode(node.left.right);
    parts.push(shouldNotHaveWhitespace ? "" : " ", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print
    // the other ones since we don't call the normal print on bin,
    // only for the left and right parts

    if (isNested && node.comments) {
      parts = comments.printAllComments(path, function () {
        return parts;
      }, options);
    }
  } else {
    // Our stopping case. Simply print the node normally.
    parts.push(path.call(print));
  }

  return parts;
}

function printLookupNodes(path, options, print) {
  var node = path.getValue();

  switch (node.kind) {
    case "propertylookup":
      return printPropertyLookup(path, options, print);

    case "nullsafepropertylookup":
      return printNullsafePropertyLookup(path, options, print);

    case "staticlookup":
      return printStaticLookup(path, options, print);

    case "offsetlookup":
      return printOffsetLookup(path, options, print);

    /* istanbul ignore next */

    default:
      return "Have not implemented lookup kind ".concat(node.kind, " yet.");
  }
}

function getEncapsedQuotes(node) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$opening = _ref.opening,
      opening = _ref$opening === void 0 ? true : _ref$opening;

  if (node.type === "heredoc") {
    return opening ? "<<<".concat(node.label) : node.label;
  }

  var quotes = {
    string: '"',
    shell: "`"
  };

  if (quotes[node.type]) {
    return quotes[node.type];
  }
  /* istanbul ignore next */


  return "Unimplemented encapsed type ".concat(node.type);
}

function printArrayItems(path, options, print) {
  var printedElements = [];
  var separatorParts = [];
  path.each(function (childPath) {
    printedElements.push(separatorParts);
    printedElements.push(group(print(childPath)));
    separatorParts = [",", line];

    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {
      separatorParts.push(softline);
    }
  }, "items");
  return printedElements;
} // Wrap parts into groups by indexes.
// It is require to have same indent on lines for all parts into group.
// The value of `alignment` option indicates how many spaces must be before each part.
//
// Example:
// <div>
//     <?php
//     echo '1';
//     echo '2';
//     echo '3';
//     ?>
// </div>


function wrapPartsIntoGroups(parts, indexes) {
  if (indexes.length === 0) {
    return parts;
  }

  var lastEnd = 0;
  return indexes.reduce(function (accumulator, index) {
    var start = index.start,
        end = index.end,
        alignment = index.alignment,
        before = index.before,
        after = index.after;
    var printedPartsForGrouping = [before || ""].concat(_toConsumableArray(parts.slice(start, end)), [after || ""]);
    var newArray = accumulator.concat(parts.slice(lastEnd, start), alignment ? dedentToRoot(group(align(new Array(alignment).join(" "), printedPartsForGrouping))) : group(printedPartsForGrouping), end === parts.length - 1 ? parts.slice(end) : "");
    lastEnd = end;
    return newArray;
  }, []);
}

function printLines(path, options, print) {
  var childrenAttribute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "children";
  var node = path.getValue();
  var parentNode = path.getParentNode();
  var lastInlineIndex = -1;
  var parts = [];
  var groupIndexes = [];
  path.map(function (childPath, index) {
    var childNode = childPath.getValue();
    var isInlineNode = childNode.kind === "inline";
    var printedPath = print(childPath);
    var children = node[childrenAttribute];
    var nextNode = children[index + 1];
    var canPrintBlankLine = !isLastStatement(childPath) && !isInlineNode && (nextNode && nextNode.kind === "case" ? !isFirstChildrenInlineNode(path) : nextNode && nextNode.kind !== "inline");
    var printed = [printedPath, canPrintBlankLine ? hardline : "", canPrintBlankLine && isNextLineEmpty(options.originalText, childNode, options) ? hardline : ""];
    var isFirstNode = index === 0;
    var isLastNode = children.length - 1 === index;
    var isBlockNestedNode = node.kind === "block" && parentNode && ["function", "closure", "method", "try", "catch"].includes(parentNode.kind);
    var beforeCloseTagInlineNode = isBlockNestedNode && isFirstNode ? "" : " ";

    if (isInlineNode || !isInlineNode && isLastNode && lastInlineIndex >= 0) {
      var prevLastInlineIndex = lastInlineIndex;

      if (isInlineNode) {
        lastInlineIndex = index;
      }

      var shouldCreateGroup = isInlineNode && !isFirstNode || !isInlineNode && isLastNode;

      if (shouldCreateGroup) {
        var start = (isInlineNode ? prevLastInlineIndex : lastInlineIndex) + 1;
        var end = isLastNode && !isInlineNode ? index + 1 : index;
        var prevInlineNode = children[isInlineNode ? prevLastInlineIndex : lastInlineIndex];
        var alignment = prevInlineNode ? getAlignment(prevInlineNode.raw) : "";
        var shouldBreak = end - start > 1;
        var before = shouldBreak ? isBlockNestedNode && !prevInlineNode || isProgramLikeNode(node) && start === 0 ? "" : hardline : "";
        var after = shouldBreak && childNode.kind !== "halt" ? isBlockNestedNode && isLastNode ? "" : hardline : "";

        if (shouldBreak) {
          beforeCloseTagInlineNode = "";
        }

        groupIndexes.push({
          start: start,
          end: end,
          alignment: alignment,
          before: before,
          after: after
        });
      }
    }

    if (isInlineNode) {
      var openTag = nextNode && nextNode.kind === "echo" && nextNode.shortForm ? "<?=" : "<?php";
      var beforeInline = childNode.leadingComments && childNode.leadingComments.length ? [isFirstNode && node.kind !== "namespace" && !isBlockNestedNode ? "<?php" : "", node.kind === "namespace" || !isBlockNestedNode ? hardline : "", comments.printComments(childNode.leadingComments, options), hardline, "?>"] : isProgramLikeNode(node) && isFirstNode && node.kind !== "namespace" ? "" : [beforeCloseTagInlineNode, "?>"];
      var nextV = path.getNode(index + 1);
      var skipLastComment = nextV && nextV.children && nextV.children.length;
      var afterInline = childNode.comments && childNode.comments.length ? [openTag, hardline, skipLastComment ? comments.printComments(childNode.comments, options) : "", hardline] : isProgramLikeNode(node) && isLastNode ? "" : [openTag, " "];
      printed = [beforeInline, printed, afterInline];
    }

    parts.push(printed);
  }, childrenAttribute);
  var wrappedParts = wrapPartsIntoGroups(parts, groupIndexes);

  if (node.kind === "program" && !node.extra.parseAsEval) {
    var _parts = [];

    var _node$children = _slicedToArray(node.children, 1),
        firstNode = _node$children[0];

    var hasStartTag = !firstNode || firstNode.kind !== "inline";

    if (hasStartTag) {
      var between = options.originalText.trim().match(/^<\?(php|=)(\s+)?\S/);
      var afterOpenTag = [between && between[2] && between[2].includes("\n") ? [hardline, between[2].split("\n").length > 2 ? hardline : ""] : " ", node.comments ? comments.printComments(node.comments, options) : ""];
      var shortEcho = firstNode && firstNode.kind === "echo" && firstNode.shortForm;

      _parts.push([shortEcho ? "<?=" : "<?php", afterOpenTag]);
    }

    _parts.push(wrappedParts);

    var hasEndTag = /\?>\n?$/.test(options.originalText);

    if (hasEndTag) {
      var lastNode = getLast(node.children);
      var beforeCloseTag = lastNode ? [hasNewlineInRange(options.originalText.trimEnd(), options.locEnd(lastNode), options.locEnd(node)) ? !(lastNode.kind === "inline" && lastNode.comments && lastNode.comments.length) ? hardline : "" : " ", isNextLineEmpty(options.originalText, lastNode, options) ? hardline : ""] : node.comments ? hardline : "";

      _parts.push(lineSuffix([beforeCloseTag, "?>"]));
    }

    return _parts;
  }

  return wrappedParts;
}

function printStatements(path, options, print, childrenAttribute) {
  return path.map(function (childPath) {
    var parts = [];
    parts.push(print(childPath));

    if (!isLastStatement(childPath)) {
      parts.push(hardline);

      if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {
        parts.push(hardline);
      }
    }

    return parts;
  }, childrenAttribute);
}

function printClassPart(path, options, print) {
  var part = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "extends";
  var beforePart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : " ";
  var afterPart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : " ";
  var node = path.getValue();
  var printedBeforePart = hasDanglingComments(node[part]) ? [hardline, path.call(function (partPath) {
    return comments.printDanglingComments(partPath, options, true);
  }, part), hardline] : beforePart;
  var printedPartItems = Array.isArray(node[part]) ? group(join(",", path.map(function (itemPartPath) {
    var printedPart = print(itemPartPath); // Check if any of the implements nodes have comments

    return hasDanglingComments(itemPartPath.getValue()) ? [hardline, comments.printDanglingComments(itemPartPath, options, true), hardline, printedPart] : [afterPart, printedPart];
  }, part))) : [afterPart, path.call(print, part)];
  return indent([printedBeforePart, part, willBreak(printedBeforePart) ? indent(printedPartItems) : printedPartItems]);
}

function printAttrs(path, options, print) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$inline = _ref2.inline,
      inline = _ref2$inline === void 0 ? false : _ref2$inline;

  var allAttrs = [];

  if (!path.getValue().attrGroups) {
    return [];
  }

  path.each(function (agPath) {
    var attrGroup = ["#["];

    if (!inline && allAttrs.length > 0) {
      allAttrs.push(hardline);
    }

    attrGroup.push(softline);
    agPath.each(function (attrPath) {
      var attrNode = attrPath.getValue();

      if (attrGroup.length > 2) {
        attrGroup.push(",", line);
      }

      var attrStmt = [attrNode.name];

      if (attrNode.args.length > 0) {
        attrStmt.push(printArgumentsList(attrPath, options, print, "args"));
      }

      attrGroup.push(group(attrStmt));
    }, "attrs");
    allAttrs.push(group([indent(attrGroup), ifBreak(shouldPrintComma(options, "8.0") ? "," : ""), softline, "]", inline ? ifBreak(softline, " ") : ""]));
  }, "attrGroups");

  if (allAttrs.length === 0) {
    return [];
  }

  return [].concat(allAttrs, [inline ? "" : hardline]);
}

function printClass(path, options, print) {
  var node = path.getValue();
  var isAnonymousClass = node.kind === "class" && node.isAnonymous;
  var attrs = printAttrs(path, options, print, {
    inline: isAnonymousClass
  });
  var declaration = isAnonymousClass ? [] : _toConsumableArray(attrs);

  if (node.isReadonly) {
    declaration.push("readonly ");
  }

  if (node.isFinal) {
    declaration.push("final ");
  }

  if (node.isAbstract) {
    declaration.push("abstract ");
  } // `new` print `class` keyword with arguments


  declaration.push(isAnonymousClass ? "" : node.kind);

  if (node.name) {
    declaration.push(" ", path.call(print, "name"));
  }

  if (node.kind === "enum" && node.valueType) {
    declaration.push(": ", path.call(print, "valueType"));
  } // Only `class` can have `extends` and `implements`


  if (node["extends"] && node["implements"]) {
    declaration.push(conditionalGroup([[printClassPart(path, options, print, "extends"), printClassPart(path, options, print, "implements")], [printClassPart(path, options, print, "extends"), printClassPart(path, options, print, "implements", " ", hardline)], [printClassPart(path, options, print, "extends", hardline, " "), printClassPart(path, options, print, "implements", hardline, node["implements"].length > 1 ? hardline : " ")]], {
      shouldBreak: hasDanglingComments(node["extends"])
    }));
  } else {
    if (node["extends"]) {
      declaration.push(conditionalGroup([printClassPart(path, options, print, "extends"), printClassPart(path, options, print, "extends", " ", hardline), printClassPart(path, options, print, "extends", hardline, node["extends"].length > 1 ? hardline : " ")]));
    }

    if (node["implements"]) {
      declaration.push(conditionalGroup([printClassPart(path, options, print, "implements"), printClassPart(path, options, print, "implements", " ", hardline), printClassPart(path, options, print, "implements", hardline, node["implements"].length > 1 ? hardline : " ")]));
    }
  }

  var printedDeclaration = group([group(declaration), shouldPrintHardlineForOpenBrace(options) ? isAnonymousClass ? line : hardline : " "]);
  var hasEmptyClassBody = node.body && node.body.length === 0 && !hasDanglingComments(node);
  var printedBody = ["{", indent([hasEmptyClassBody ? "" : hardline, printStatements(path, options, print, "body")]), comments.printDanglingComments(path, options, true), isAnonymousClass && hasEmptyClassBody ? softline : hardline, "}"];
  return [printedDeclaration, printedBody];
}

function printFunction(path, options, print) {
  var node = path.getValue();
  var declAttrs = printAttrs(path, options, print, {
    inline: node.kind === "closure"
  });
  var declaration = [];

  if (node.isFinal) {
    declaration.push("final ");
  }

  if (node.isAbstract) {
    declaration.push("abstract ");
  }

  if (node.visibility) {
    declaration.push(node.visibility, " ");
  }

  if (node.isStatic) {
    declaration.push("static ");
  }

  declaration.push("function ");

  if (node.byref) {
    declaration.push("&");
  }

  if (node.name) {
    declaration.push(path.call(print, "name"));
  }

  declaration.push(printArgumentsList(path, options, print));

  if (node.uses && node.uses.length > 0) {
    declaration.push(group([" use ", printArgumentsList(path, options, print, "uses")]));
  }

  if (node.type) {
    declaration.push([": ", hasDanglingComments(node.type) ? [path.call(function (typePath) {
      return comments.printDanglingComments(typePath, options, true);
    }, "type"), " "] : "", node.nullable ? "?" : "", path.call(print, "type")]);
  }

  var printedDeclaration = declaration;

  if (!node.body) {
    return [].concat(_toConsumableArray(declAttrs), [printedDeclaration]);
  }

  var isClosure = node.kind === "closure";
  var printedBody = ["{", indent([hasEmptyBody(path) ? "" : hardline, path.call(print, "body")]), isClosure && hasEmptyBody(path) ? "" : hardline, "}"];

  if (isClosure) {
    return [].concat(_toConsumableArray(declAttrs), [printedDeclaration, " ", printedBody]);
  }

  if (node.arguments.length === 0) {
    return [].concat(_toConsumableArray(declAttrs), [printedDeclaration, shouldPrintHardlineForOpenBrace(options) ? hardline : " ", printedBody]);
  }

  var willBreakDeclaration = declaration.some(willBreak);

  if (willBreakDeclaration) {
    return [printedDeclaration, " ", printedBody];
  }

  return [].concat(_toConsumableArray(declAttrs), [conditionalGroup([[printedDeclaration, shouldPrintHardlineForOpenBrace(options) ? hardline : " ", printedBody], [printedDeclaration, " ", printedBody]])]);
}

function printBodyControlStructure(path, options, print) {
  var bodyProperty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "body";
  var node = path.getValue();

  if (!node[bodyProperty]) {
    return ";";
  }

  var printedBody = path.call(print, bodyProperty);
  return [node.shortForm ? ":" : " {", indent(node[bodyProperty].kind !== "block" || node[bodyProperty].children && node[bodyProperty].children.length > 0 || node[bodyProperty].comments && node[bodyProperty].comments.length > 0 ? [shouldPrintHardLineAfterStartInControlStructure(path) ? node.kind === "switch" ? " " : "" : hardline, printedBody] : ""), node.kind === "if" && bodyProperty === "body" ? "" : [shouldPrintHardLineBeforeEndInControlStructure(path) ? hardline : "", node.shortForm ? ["end", node.kind, ";"] : "}"]];
}

function printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, hasRef, options) {
  if (!rightNode) {
    return printedLeft;
  }

  var printed = printAssignmentRight(leftNode, rightNode, printedRight, hasRef, options);
  return group([printedLeft, operator, printed]);
}

function isLookupNodeChain(node) {
  if (!isLookupNode(node)) {
    return false;
  }

  if (node.what.kind === "variable" || isReferenceLikeNode(node.what)) {
    return true;
  }

  return isLookupNodeChain(node.what);
}

function printAssignmentRight(leftNode, rightNode, printedRight, hasRef, options) {
  var ref = hasRef ? "&" : "";

  if (comments.hasLeadingOwnLineComment(options.originalText, rightNode, options)) {
    return indent([hardline, ref, printedRight]);
  }

  var pureRightNode = rightNode.kind === "cast" ? rightNode.expr : rightNode;
  var canBreak = pureRightNode.kind === "bin" && !shouldInlineLogicalExpression(pureRightNode) || pureRightNode.kind === "retif" && (!pureRightNode.trueExpr && !shouldInlineRetifFalseExpression(pureRightNode.falseExpr) || pureRightNode.test.kind === "bin" && !shouldInlineLogicalExpression(pureRightNode.test)) || (leftNode.kind === "variable" || leftNode.kind === "string" || isLookupNode(leftNode)) && (pureRightNode.kind === "string" && !stringHasNewLines(pureRightNode) || isLookupNodeChain(pureRightNode));

  if (canBreak) {
    return group(indent([line, ref, printedRight]));
  }

  return [" ", ref, printedRight];
}

function needsHardlineAfterDanglingComment(node) {
  if (!node.comments) {
    return false;
  }

  var lastDanglingComment = getLast(node.comments.filter(function (comment) {
    return !comment.leading && !comment.trailing;
  }));
  return lastDanglingComment && !comments.isBlockComment(lastDanglingComment);
}

function stringHasNewLines(node) {
  return node.raw.includes("\n");
}

function isStringOnItsOwnLine(node, text, options) {
  return (node.kind === "string" || node.kind === "encapsed" && (node.type === "string" || node.type === "shell")) && stringHasNewLines(node) && !hasNewline(text, options.locStart(node), {
    backwards: true
  });
}

function printComposedTypes(path, print, glue) {
  return group(path.map(function (uPath, i) {
    return i === 0 ? [path.call(print)] : [glue, path.call(print)];
  }, "types"));
}

function printNode(path, options, print) {
  var node = path.getValue();

  switch (node.kind) {
    case "program":
      {
        return group([printLines(path, options, print), comments.printDanglingComments(path, options,
        /* sameIndent */
        true, function (c) {
          return !c.printed;
        })]);
      }

    case "expressionstatement":
      return path.call(print, "expression");

    case "block":
      return [printLines(path, options, print), comments.printDanglingComments(path, options, true)];

    case "declare":
      {
        var printDeclareArguments = function printDeclareArguments(path) {
          return join(", ", path.map(function (directive) {
            return print(directive);
          }, "directives"));
        };

        if (["block", "short"].includes(node.mode)) {
          return ["declare(", printDeclareArguments(path), ")", node.mode === "block" ? " {" : ":", node.children.length > 0 ? indent([hardline, printLines(path, options, print)]) : "", comments.printDanglingComments(path, options), hardline, node.mode === "block" ? "}" : "enddeclare;"];
        }

        var nextNode = getNextNode(path, node);
        return ["declare(", printDeclareArguments(path), ")", nextNode && nextNode.kind === "inline" ? "" : ";"];
      }

    case "declaredirective":
      return [path.call(print, "key"), "=", path.call(print, "value")];

    case "namespace":
      return ["namespace ", node.name && typeof node.name === "string" ? [node.name, node.withBrackets ? " " : ""] : "", node.withBrackets ? "{" : ";", hasDanglingComments(node) ? [" ", comments.printDanglingComments(path, options, true)] : "", node.children.length > 0 ? node.withBrackets ? indent([hardline, printLines(path, options, print)]) : [node.children[0].kind === "inline" ? "" : [hardline, isNextLineEmptyAfterNamespace(options.originalText, node, options.locStart) ? hardline : ""], printLines(path, options, print)] : "", node.withBrackets ? [hardline, "}"] : ""];

    case "usegroup":
      return group(["use ", node.type ? [node.type, " "] : "", indent([node.name ? [maybeStripLeadingSlashFromUse(node.name), "\\{", softline] : "", join([",", line], path.map(function (item) {
        return print(item);
      }, "items"))]), node.name ? [ifBreak(shouldPrintComma(options, "7.2") ? "," : ""), softline, "}"] : ""]);

    case "useitem":
      return [node.type ? [node.type, " "] : "", maybeStripLeadingSlashFromUse(node.name), hasDanglingComments(node) ? [" ", comments.printDanglingComments(path, options, true)] : "", node.alias ? [" as ", path.call(print, "alias")] : ""];

    case "class":
    case "enum":
    case "interface":
    case "trait":
      return printClass(path, options, print);

    case "traitprecedence":
      return [path.call(print, "trait"), "::", path.call(print, "method"), " insteadof ", join(", ", path.map(print, "instead"))];

    case "traitalias":
      return [node.trait ? [path.call(print, "trait"), "::"] : "", node.method ? path.call(print, "method") : "", " as ", join(" ", [].concat(_toConsumableArray(node.visibility ? [node.visibility] : []), _toConsumableArray(node.as ? [path.call(print, "as")] : [])))];

    case "traituse":
      return group(["use ", indent(group(join([",", line], path.map(print, "traits")))), node.adaptations ? [" {", node.adaptations.length > 0 ? [indent([hardline, printStatements(path, options, print, "adaptations")]), hardline] : hasDanglingComments(node) ? [line, comments.printDanglingComments(path, options, true), line] : "", "}"] : ""]);

    case "function":
    case "closure":
    case "method":
      return printFunction(path, options, print);

    case "arrowfunc":
      return [node.parenthesizedExpression ? "(" : ""].concat(_toConsumableArray(printAttrs(path, options, print, {
        inline: true
      })), [node.isStatic ? "static " : "", "fn", printArgumentsList(path, options, print), node.type ? [": ", node.nullable ? "?" : "", path.call(print, "type")] : "", " => ", path.call(print, "body"), node.parenthesizedExpression ? ")" : ""]);

    case "parameter":
      {
        var promoted = "";

        if (node.flags === 1) {
          promoted = "public ";
        } else if (node.flags === 2) {
          promoted = "protected ";
        } else if (node.flags === 4) {
          promoted = "private ";
        }

        var name = [].concat(_toConsumableArray(printAttrs(path, options, print, {
          inline: true
        })), [promoted, node.readonly ? "readonly " : "", node.nullable ? "?" : "", node.type ? [path.call(print, "type"), " "] : "", node.byref ? "&" : "", node.variadic ? "..." : "", "$", path.call(print, "name")]);

        if (node.value) {
          return group([name, // see handleFunctionParameter() in ./comments.js - since there's
          // no node to attach comments that fall in between the parameter name
          // and value, we store them as dangling comments
          hasDanglingComments(node) ? " " : "", comments.printDanglingComments(path, options, true), " =", printAssignmentRight(node.name, node.value, path.call(print, "value"), false, options)]);
        }

        return name;
      }

    case "variadic":
      return ["...", path.call(print, "what")];

    case "property":
      return group([node.readonly ? "readonly " : "", node.type ? [node.nullable ? "?" : "", path.call(print, "type"), " "] : "", "$", path.call(print, "name"), node.value ? [" =", printAssignmentRight(node.name, node.value, path.call(print, "value"), false, options)] : ""]);

    case "propertystatement":
      {
        var attrs = [];
        path.map(function (propPath) {
          return attrs.push.apply(attrs, _toConsumableArray(printAttrs(propPath, options, print)));
        }, "properties");
        var printed = path.map(function (childPath) {
          return print(childPath);
        }, "properties");
        var hasValue = node.properties.some(function (property) {
          return property.value;
        });
        var firstProperty;

        if (printed.length === 1 && !node.properties[0].comments) {
          var _printed = _slicedToArray(printed, 1);

          firstProperty = _printed[0];
        } else if (printed.length > 0) {
          // Indent first property
          firstProperty = indent(printed[0]);
        }

        var hasVisibility = node.visibility || node.visibility === null;
        return group([].concat(attrs, [hasVisibility ? [node.visibility === null ? "var" : node.visibility, ""] : "", node.isStatic ? [hasVisibility ? " " : "", "static"] : "", firstProperty ? [" ", firstProperty] : "", indent(printed.slice(1).map(function (p) {
          return [",", hasValue ? hardline : line, p];
        }))]));
      }

    case "if":
      {
        var parts = [];
        var body = printBodyControlStructure(path, options, print, "body");
        var opening = group(["if (", group([indent([softline, path.call(print, "test")]), softline]), ")", body]);
        parts.push(opening, isFirstChildrenInlineNode(path) || !node.body ? "" : hardline);

        if (node.alternate) {
          parts.push(node.shortForm ? "" : "} ");
          var commentOnOwnLine = hasTrailingComment(node.body) && node.body.comments.some(function (comment) {
            return comment.trailing && !comments.isBlockComment(comment);
          }) || needsHardlineAfterDanglingComment(node);
          var elseOnSameLine = !commentOnOwnLine;
          parts.push(elseOnSameLine ? "" : hardline);

          if (hasDanglingComments(node)) {
            parts.push(isNextLineEmpty(options.originalText, node.body, options) ? hardline : "", comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : " ");
          }

          parts.push("else", group(node.alternate.kind === "if" ? path.call(print, "alternate") : printBodyControlStructure(path, options, print, "alternate")));
        } else {
          parts.push(node.body ? node.shortForm ? "endif;" : "}" : "");
        }

        return parts;
      }

    case "do":
      return ["do", printBodyControlStructure(path, options, print, "body"), " while (", group([indent([softline, path.call(print, "test")]), softline]), ")"];

    case "while":
    case "switch":
      return group([node.kind, " (", group([indent([softline, path.call(print, "test")]), softline]), ")", printBodyControlStructure(path, options, print, "body")]);

    case "for":
      {
        var _body = printBodyControlStructure(path, options, print, "body"); // We want to keep dangling comments above the loop to stay consistent.
        // Any comment positioned between the for statement and the parentheses
        // is going to be printed before the statement.


        var dangling = comments.printDanglingComments(path, options,
        /* sameLine */
        true);
        var printedComments = dangling ? [dangling, softline] : "";

        if (!node.init.length && !node.test.length && !node.increment.length) {
          return [printedComments, group(["for (;;)", _body])];
        }

        return [printedComments, group(["for (", group([indent([softline, group(join([",", line], path.map(print, "init"))), ";", line, group(join([",", line], path.map(print, "test"))), ";", line, group(join([",", line], path.map(print, "increment")))]), softline]), ")", _body])];
      }

    case "foreach":
      {
        var _body2 = printBodyControlStructure(path, options, print, "body"); // We want to keep dangling comments above the loop to stay consistent.
        // Any comment positioned between the for statement and the parentheses
        // is going to be printed before the statement.


        var _dangling = comments.printDanglingComments(path, options,
        /* sameLine */
        true);

        var _printedComments = _dangling ? [_dangling, softline] : "";

        return [_printedComments, group(["foreach (", group([indent([softline, path.call(print, "source"), line, "as ", group(node.key ? indent(join([" =>", line], [path.call(print, "key"), path.call(print, "value")])) : path.call(print, "value"))]), softline]), ")", _body2])];
      }

    case "try":
      {
        var _parts2 = [];

        _parts2.push("try", printBodyControlStructure(path, options, print, "body"));

        if (node.catches) {
          _parts2.push(path.map(print, "catches"));
        }

        if (node.always) {
          _parts2.push(" finally", printBodyControlStructure(path, options, print, "always"));
        }

        return _parts2;
      }

    case "catch":
      {
        return [" catch", node.what ? [" (", join(" | ", path.map(print, "what")), node.variable ? [" ", path.call(print, "variable")] : "", ")"] : "", printBodyControlStructure(path, options, print, "body")];
      }

    case "case":
      return [node.test ? ["case ", node.test.comments ? indent(path.call(print, "test")) : path.call(print, "test"), ":"] : "default:", node.body ? node.body.children && node.body.children.length ? indent([isFirstChildrenInlineNode(path) ? "" : hardline, path.call(print, "body")]) : "" : ""];

    case "break":
    case "continue":
      if (node.level) {
        if (node.level.kind === "number" && node.level.value !== "1") {
          return ["".concat(node.kind, " "), path.call(print, "level")];
        }

        return node.kind;
      }

      return node.kind;

    case "call":
      {
        // Multiline strings as single arguments
        if (node.arguments.length === 1 && isStringOnItsOwnLine(node.arguments[0], options.originalText, options)) {
          return [path.call(print, "what"), "(", join(", ", path.map(print, "arguments")), ")"];
        } // chain: Call (*LookupNode (Call (*LookupNode (...))))


        if (isLookupNode(node.what)) {
          return printMemberChain(path, options, print);
        }

        return [path.call(print, "what"), printArgumentsList(path, options, print)];
      }

    case "new":
      {
        var isAnonymousClassNode = node.what && node.what.kind === "class" && node.what.isAnonymous; // Multiline strings as single arguments

        if (!isAnonymousClassNode && node.arguments.length === 1 && isStringOnItsOwnLine(node.arguments[0], options.originalText, options)) {
          return ["new "].concat(_toConsumableArray(path.call(printAttrs, "what")), [path.call(print, "what"), "(", join(", ", path.map(print, "arguments")), ")"]);
        }

        var _parts3 = [];

        _parts3.push("new ");

        if (isAnonymousClassNode) {
          _parts3.push.apply(_parts3, [node.what.leadingComments && node.what.leadingComments[0].kind === "commentblock" ? [comments.printComments(node.what.leadingComments, options), " "] : ""].concat(_toConsumableArray(path.call(function (pa) {
            return printAttrs(pa, options, print, {
              inline: true
            });
          }, "what")), ["class", node.arguments.length > 0 ? [" ", printArgumentsList(path, options, print)] : "", group(path.call(print, "what"))]));
        } else {
          var isExpression = ["call", "offsetlookup"].includes(node.what.kind);
          var _printed2 = [isExpression ? "(" : "", path.call(print, "what"), isExpression ? ")" : "", printArgumentsList(path, options, print)];

          _parts3.push(hasLeadingComment(node.what) ? indent(_printed2) : _printed2);
        }

        return _parts3;
      }

    case "clone":
      return ["clone ", node.what.comments ? indent(path.call(print, "what")) : path.call(print, "what")];

    case "propertylookup":
    case "nullsafepropertylookup":
    case "staticlookup":
    case "offsetlookup":
      {
        var parent = path.getParentNode();
        var firstNonMemberParent;
        var i = 0;

        do {
          firstNonMemberParent = path.getParentNode(i);
          i++;
        } while (firstNonMemberParent && isLookupNode(firstNonMemberParent));

        var hasEncapsedAncestor = getAncestorNode(path, "encapsed");
        var shouldInline = hasEncapsedAncestor || firstNonMemberParent && (firstNonMemberParent.kind === "new" || firstNonMemberParent.kind === "assign" && firstNonMemberParent.left.kind !== "variable") || node.kind === "offsetlookup" || (isReferenceLikeNode(node.what) || node.what.kind === "variable") && ["identifier", "variable", "encapsedpart"].includes(node.offset.kind) && parent && !isLookupNode(parent);
        return [path.call(print, "what"), shouldInline ? printLookupNodes(path, options, print) : group(indent([softline, printLookupNodes(path, options, print)]))];
      }

    case "exit":
      return group([node.useDie ? "die" : "exit", "(", node.expression ? isStringOnItsOwnLine(node.expression, options.originalText, options) ? path.call(print, "expression") : [indent([softline, path.call(print, "expression")]), softline] : comments.printDanglingComments(path, options), ")"]);

    case "global":
      return group(["global ", indent(join([",", line], path.map(print, "items")))]);

    case "include":
      return [node.require ? "require" : "include", node.once ? "_once" : "", " ", node.target.comments ? indent(path.call(print, "target")) : path.call(print, "target")];

    case "label":
      return [path.call(print, "name"), ":"];

    case "goto":
      return ["goto ", path.call(print, "label")];

    case "throw":
      return ["throw ", node.what.comments ? indent(path.call(print, "what")) : path.call(print, "what")];

    case "silent":
      return ["@", path.call(print, "expr")];

    case "halt":
      return [hasDanglingComments(node) ? [comments.printDanglingComments(path, options,
      /* sameIndent */
      true), hardline] : "", "__halt_compiler();", node.after];

    case "eval":
      return group(["eval(", isStringOnItsOwnLine(node.source, options.originalText, options) ? path.call(print, "source") : [indent([softline, path.call(print, "source")]), softline], ")"]);

    case "echo":
      {
        var printedArguments = path.map(function (childPath) {
          return print(childPath);
        }, "expressions");
        var firstVariable;

        if (printedArguments.length === 1 && !node.expressions[0].comments) {
          var _printedArguments = _slicedToArray(printedArguments, 1);

          firstVariable = _printedArguments[0];
        } else if (printedArguments.length > 0) {
          firstVariable = isDocNode(node.expressions[0]) || node.expressions[0].comments ? indent(printedArguments[0]) : dedent(printedArguments[0]);
        }

        return group([node.shortForm ? "" : "echo ", firstVariable ? firstVariable : "", indent(printedArguments.slice(1).map(function (p) {
          return [",", line, p];
        }))]);
      }

    case "print":
      {
        return ["print ", node.expression.comments ? indent(path.call(print, "expression")) : path.call(print, "expression")];
      }

    case "return":
      {
        var _parts4 = [];

        _parts4.push("return");

        if (node.expr) {
          var printedExpr = path.call(print, "expr");

          _parts4.push(" ", node.expr.comments ? indent(printedExpr) : printedExpr);
        }

        if (hasDanglingComments(node)) {
          _parts4.push(" ", comments.printDanglingComments(path, options,
          /* sameIndent */
          true));
        }

        return _parts4;
      }

    case "isset":
    case "unset":
      return group([node.kind, printArgumentsList(path, options, print, "variables")]);

    case "empty":
      return group(["empty(", indent([softline, path.call(print, "expression")]), softline, ")"]);

    case "variable":
      {
        var _parent = path.getParentNode();

        var parentParent = path.getParentNode(1);
        var ampersand = _parent.kind === "assign" ? "" : node.byref ? "&" : "";
        var dollar = _parent.kind === "encapsedpart" && _parent.syntax === "simple" && _parent.curly || parentParent && _parent.kind === "offsetlookup" && parentParent.kind === "encapsedpart" && parentParent.syntax === "simple" && parentParent.curly ? "" : "$";
        var openCurly = node.curly ? "{" : "";
        var closeCurly = node.curly ? "}" : "";
        return [ampersand, dollar, openCurly, path.call(print, "name"), closeCurly];
      }

    case "constantstatement":
    case "classconstant":
      {
        var _attrs = printAttrs(path, options, print);

        var _printed3 = path.map(function (childPath) {
          return print(childPath);
        }, "constants");

        var _firstVariable;

        if (_printed3.length === 1 && !node.constants[0].comments) {
          var _printed4 = _slicedToArray(_printed3, 1);

          _firstVariable = _printed4[0];
        } else if (_printed3.length > 0) {
          // Indent first item
          _firstVariable = indent(_printed3[0]);
        }

        return group([].concat(_toConsumableArray(_attrs), [node.visibility ? [node.visibility, " "] : "", "const", _firstVariable ? [" ", _firstVariable] : "", indent(_printed3.slice(1).map(function (p) {
          return [",", hardline, p];
        }))]));
      }

    case "constant":
      return printAssignment(node.name, path.call(print, "name"), " =", node.value, path.call(print, "value"), false, options);

    case "static":
      {
        var _printed5 = path.map(function (childPath) {
          return print(childPath);
        }, "variables");

        var _hasValue = node.variables.some(function (item) {
          return item.defaultValue;
        });

        var _firstVariable2;

        if (_printed5.length === 1 && !node.variables[0].comments) {
          var _printed6 = _slicedToArray(_printed5, 1);

          _firstVariable2 = _printed6[0];
        } else if (_printed5.length > 0) {
          // Indent first item
          _firstVariable2 = indent(_printed5[0]);
        }

        return group(["static", _firstVariable2 ? [" ", _firstVariable2] : "", indent(_printed5.slice(1).map(function (p) {
          return [",", _hasValue ? hardline : line, p];
        }))]);
      }

    case "staticvariable":
      {
        return printAssignment(node.variable, path.call(print, "variable"), " =", node.defaultValue, path.call(print, "defaultValue"), false, options);
      }

    case "list":
    case "array":
      {
        var useShortForm = node.kind === "array" && isMinVersion(options.phpVersion, "5.4") || node.kind === "list" && (node.shortForm || isMinVersion(options.phpVersion, "7.1"));
        var open = useShortForm ? "[" : [node.kind, "("];
        var close = useShortForm ? "]" : ")";

        if (node.items.length === 0) {
          if (!hasDanglingComments(node)) {
            return [open, close];
          }

          return group([open, comments.printDanglingComments(path, options), softline, close]);
        }

        var lastElem = getLast(node.items); // PHP allows you to have empty elements in an array which
        // changes its length based on the number of commas. The algorithm
        // is that if the last argument is null, we need to force insert
        // a comma to ensure PHP recognizes it.
        //   [,] === $arr;
        //   [1,] === $arr;
        //   [1,,] === $arr;
        //
        // Note that getLast returns null if the array is empty, but
        // we already check for an empty array just above so we are safe

        var needsForcedTrailingComma = lastElem && lastElem.kind === "noop";

        var _node$items$filter$so = node.items.filter(function (node) {
          return node.kind !== "noop";
        }).sort(function (a, b) {
          return options.locStart(a) - options.locStart(b);
        }),
            _node$items$filter$so2 = _slicedToArray(_node$items$filter$so, 1),
            _firstProperty = _node$items$filter$so2[0];

        var isAssociative = !!(_firstProperty && _firstProperty.key);
        var shouldBreak = isAssociative && _firstProperty && hasNewlineInRange(options.originalText, options.locStart(node), options.locStart(_firstProperty));
        return group([open, indent([softline, printArrayItems(path, options, print)]), needsForcedTrailingComma ? "," : "", ifBreak(!needsForcedTrailingComma && shouldPrintComma(options, "5.0") ? [lastElem && shouldPrintHardlineBeforeTrailingComma(lastElem) ? hardline : "", ","] : ""), comments.printDanglingComments(path, options, true), softline, close], {
          shouldBreak: shouldBreak
        });
      }

    case "entry":
      {
        var ref = node.byRef ? "&" : "";
        var unpack = node.unpack ? "..." : "";
        return node.key ? printAssignment(node.key, path.call(print, "key"), " =>", node.value, path.call(print, "value"), ref, options) : [ref, unpack, path.call(print, "value")];
      }

    case "yield":
      {
        var printedKeyAndValue = [node.key ? [path.call(print, "key"), " => "] : "", path.call(print, "value")];
        return ["yield", node.key || node.value ? " " : "", node.value && node.value.comments ? indent(printedKeyAndValue) : printedKeyAndValue];
      }

    case "yieldfrom":
      return ["yield from ", node.value.comments ? indent(path.call(print, "value")) : path.call(print, "value")];

    case "unary":
      return [node.type, path.call(print, "what")];

    case "pre":
      return [node.type + node.type, path.call(print, "what")];

    case "post":
      return [path.call(print, "what"), node.type + node.type];

    case "cast":
      return ["(", node.type, ") ", node.expr.comments ? indent(path.call(print, "expr")) : path.call(print, "expr")];

    case "assignref":
    case "assign":
      {
        var hasRef = node.kind === "assignref";
        return printAssignment(node.left, path.call(print, "left"), [" ", hasRef ? "=" : node.operator], node.right, path.call(print, "right"), hasRef, options);
      }

    case "bin":
      {
        var _parent2 = path.getParentNode();

        var _parentParent = path.getParentNode(1);

        var isInsideParenthesis = node !== _parent2.body && (_parent2.kind === "if" || _parent2.kind === "while" || _parent2.kind === "switch" || _parent2.kind === "do");

        var _parts5 = printBinaryExpression(path, print, options,
        /* isNested */
        false, isInsideParenthesis); //   if (
        //     $this->hasPlugin('dynamicImports') && $this->lookahead()->type === tt->parenLeft
        //   ) {
        //
        // looks super weird, we want to break the children if the parent breaks
        //
        //   if (
        //     $this->hasPlugin('dynamicImports') &&
        //     $this->lookahead()->type === tt->parenLeft
        //   ) {


        if (isInsideParenthesis) {
          return _parts5;
        } // Break between the parens in unaries or in a member expression, i.e.
        //
        //   (
        //     a &&
        //     b &&
        //     c
        //   )->call()


        if (_parent2.kind === "unary" || isLookupNode(_parent2) && _parent2.kind !== "offsetlookup") {
          return group([indent([softline].concat(_toConsumableArray(_parts5))), softline]);
        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already
        // indented accordingly. We should indent sub-expressions where the first case isn't indented.


        var shouldNotIndent = node !== _parent2.body && _parent2.kind === "for" || _parent2.kind === "retif" && _parentParent && _parentParent.kind !== "return";
        var shouldIndentIfInlining = ["assign", "property", "constant", "staticvariable", "entry"].includes(_parent2.kind);
        var samePrecedenceSubExpression = node.left.kind === "bin" && shouldFlatten(node.type, node.left.type);

        if (shouldNotIndent || shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(node) && shouldIndentIfInlining) {
          return group(_parts5);
        }

        var rest = _parts5.slice(1);

        return group([// Don't include the initial expression in the indentation
        // level. The first item is guaranteed to be the first
        // left-most expression.
        _parts5.length > 0 ? _parts5[0] : "", indent(rest)]);
      }

    case "retif":
      {
        var _parts6 = [];

        var _parent3 = path.getParentNode(); // Find the outermost non-retif parent, and the outermost retif parent.


        var currentParent;
        var _i3 = 0;

        do {
          currentParent = path.getParentNode(_i3);
          _i3++;
        } while (currentParent && currentParent.kind === "retif");

        var firstNonRetifParent = currentParent || _parent3;
        var printedFalseExpr = node.falseExpr.kind === "bin" ? indent(path.call(print, "falseExpr")) : path.call(print, "falseExpr");
        var part = [node.trueExpr ? line : " ", "?", node.trueExpr ? [" ", node.trueExpr.kind === "bin" ? indent(path.call(print, "trueExpr")) : path.call(print, "trueExpr"), line] : "", ":", node.trueExpr ? [" ", printedFalseExpr] : [shouldInlineRetifFalseExpression(node.falseExpr) ? " " : line, printedFalseExpr]];

        _parts6.push(part); // We want a whole chain of retif to all break if any of them break.


        var maybeGroup = function maybeGroup(doc) {
          return _parent3 === firstNonRetifParent ? group(doc) : doc;
        }; // Break the closing parens to keep the chain right after it:
        // ($a
        //   ? $b
        //   : $c
        // )->call()


        var _parentParent2 = path.getParentNode(1);

        var pureParent = _parent3.kind === "cast" && _parentParent2 ? _parentParent2 : _parent3;
        var breakLookupNodes = ["propertylookup", "nullsafepropertylookup", "staticlookup"];
        var breakClosingParens = breakLookupNodes.includes(pureParent.kind);
        var printedTest = path.call(print, "test");

        if (!node.trueExpr) {
          var _printed7 = [printedTest, pureParent.kind === "bin" || ["print", "echo", "return", "include"].includes(firstNonRetifParent.kind) ? indent(_parts6) : _parts6]; // Break between the parens in unaries or in a lookup nodes, i.e.
          //
          //   (
          //     a ?:
          //     b ?:
          //     c
          //   )->call()

          if (pureParent.kind === "call" && pureParent.what === node || pureParent.kind === "unary" || isLookupNode(pureParent) && pureParent.kind !== "offsetlookup") {
            return group([indent([softline, _printed7]), softline]);
          }

          return maybeGroup(_printed7);
        }

        return maybeGroup([node.test.kind === "retif" ? indent(printedTest) : printedTest, indent(_parts6), breakClosingParens ? softline : ""]);
      }

    case "boolean":
      return node.value ? "true" : "false";

    case "number":
      return printNumber(node.value);

    case "string":
      {
        var _parent4 = path.getParentNode();

        if (_parent4.kind === "encapsedpart") {
          var _parentParent3 = path.getParentNode(1);

          var closingTagIndentation = 0;
          var flexible = isMinVersion(options.phpVersion, "7.3");
          var linebreak = literalline;

          if (_parentParent3.type === "heredoc") {
            linebreak = flexible ? hardline : literalline;

            var lines = _parentParent3.raw.split("\n");

            closingTagIndentation = lines[lines.length - 1].search(/\S/);

            if (closingTagIndentation === -1) {
              closingTagIndentation = lines[lines.length - 2].search(/\S/);
            }
          }

          return join(linebreak, node.raw.split("\n").map(function (s, i) {
            return i > 0 || node.loc.start.column === 0 ? s.substring(closingTagIndentation) : s;
          }));
        }

        var quote = useDoubleQuote(node, options) ? '"' : "'";
        var stringValue = node.raw;

        if (node.raw[0] === "b") {
          stringValue = stringValue.slice(1);
        } // We need to strip out the quotes from the raw value


        if (['"', "'"].includes(stringValue[0])) {
          stringValue = stringValue.substr(1);
        }

        if (['"', "'"].includes(stringValue[stringValue.length - 1])) {
          stringValue = stringValue.substr(0, stringValue.length - 1);
        }

        return [node.raw[0] === "b" ? "b" : "", quote, join(literalline, stringValue.split("\n")), quote];
      }

    case "intersectiontype":
      {
        return printComposedTypes(path, print, "&");
      }

    case "uniontype":
      {
        return printComposedTypes(path, print, "|");
      }

    case "encapsedpart":
      {
        var _open = node.syntax === "simple" && node.curly || node.syntax === "complex" ? [node.curly ? "$" : "", "{"] : "";

        var _close = node.syntax === "simple" && node.curly || node.syntax === "complex" ? "}" : "";

        return [_open, path.call(print, "expression"), _close];
      }

    case "encapsed":
      switch (node.type) {
        case "string":
        case "shell":
        case "heredoc":
          {
            var _flexible = isMinVersion(options.phpVersion, "7.3");

            var _linebreak = _flexible ? hardline : literalline;

            return [getEncapsedQuotes(node), // Respect `indent` for `heredoc` nodes
            node.type === "heredoc" ? _linebreak : ""].concat(_toConsumableArray(path.map(print, "value")), [getEncapsedQuotes(node, {
              opening: false
            }), node.type === "heredoc" && docShouldHaveTrailingNewline(path) ? hardline : ""]);
          }
        // istanbul ignore next

        default:
          return "Have not implemented kind ".concat(node.type, " yet.");
      }

    case "inline":
      return join(literalline, node.raw.replace("___PSEUDO_INLINE_PLACEHOLDER___", "").split("\n"));

    case "magic":
      return node.value;

    case "nowdoc":
      {
        var _flexible2 = isMinVersion(options.phpVersion, "7.3");

        var _linebreak2 = _flexible2 ? hardline : literalline;

        return ["<<<'", node.label, "'", _linebreak2, join(_linebreak2, node.value.split("\n")), _linebreak2, node.label, docShouldHaveTrailingNewline(path) ? hardline : ""];
      }

    case "name":
      return [node.resolution === "rn" ? "namespace\\" : "", node.name];

    case "literal":
      return path.call(print, "value");

    case "parentreference":
      return "parent";

    case "selfreference":
      return "self";

    case "staticreference":
      return "static";

    case "typereference":
      return node.name;

    case "nullkeyword":
      return "null";

    case "identifier":
      {
        var _parent5 = path.getParentNode();

        if (_parent5.kind === "method") {
          node.name = normalizeMagicMethodName(node.name);
        }

        return path.call(print, "name");
      }

    case "match":
      {
        var arms = path.map(function (armPath, armIdx) {
          var conds = armPath.getValue().conds === null ? "default" : armPath.map(function (condPath, condIdx) {
            return [",", line, print(condPath)].slice(condIdx === 0 ? 2 : 0);
          }, "conds");
          var body = armPath.call(print, "body");
          return [",", hardline, group([group([conds, indent(line)]), "=> ", body])].slice(armIdx > 0 ? 0 : 1);
        }, "arms");
        return group(["match (", group([softline, indent(path.call(print, "cond")), softline]), ") {", group(indent([].concat(_toConsumableArray(arms), [options.trailingCommaPHP ? ifBreak(",") : ""]))), " ", softline, "}"]);
      }

    case "noop":
      return node.comments ? comments.printComments(path.getValue().comments, options) : "";

    case "namedargument":
      return [node.name, ": ", path.call(print, "value")];

    case "enumcase":
      return group(["case ", path.call(print, "name"), node.value ? [" =", printAssignmentRight(node.name, node.value, path.call(print, "value"), false, options)] : ""]);

    case "variadicplaceholder":
      return "...";

    case "error":
    default:
      // istanbul ignore next
      return "Have not implemented kind ".concat(node.kind, " yet.");
  }
}

module.exports = genericPrint;