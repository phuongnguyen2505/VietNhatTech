"use strict";

var parse = require("./parser");

var print = require("./printer");

var clean = require("./clean");

var options = require("./options");

var comments = require("./comments");

var _require$doc$builders = require("prettier").doc.builders,
    join = _require$doc$builders.join,
    hardline = _require$doc$builders.hardline;

var _require = require("./pragma"),
    hasPragma = _require.hasPragma,
    insertPragma = _require.insertPragma;

function createLanguage(linguistData, _ref) {
  var extend = _ref.extend,
      override = _ref.override;
  var language = {};

  for (var key in linguistData) {
    var newKey = key === "languageId" ? "linguistLanguageId" : key;
    language[newKey] = linguistData[key];
  }

  if (extend) {
    for (var _key in extend) {
      language[_key] = (language[_key] || []).concat(extend[_key]);
    }
  }

  for (var _key2 in override) {
    language[_key2] = override[_key2];
  }

  return language;
}

var languages = [createLanguage(require("linguist-languages/data/PHP"), {
  override: {
    parsers: ["php"],
    vscodeLanguageIds: ["php"]
  }
}), createLanguage(require("linguist-languages/data/HTML+PHP"), {
  override: {
    parsers: ["php"],
    vscodeLanguageIds: ["php"]
  }
})];

var loc = function loc(prop) {
  return function (node) {
    return node.loc && node.loc[prop] && node.loc[prop].offset;
  };
};

var parsers = {
  php: {
    parse: parse,
    astFormat: "php",
    locStart: loc("start"),
    locEnd: loc("end"),
    hasPragma: hasPragma
  }
};
var printers = {
  php: {
    print: print,
    insertPragma: insertPragma,
    massageAstNode: clean,
    getCommentChildNodes: comments.getCommentChildNodes,
    canAttachComment: comments.canAttachComment,
    isBlockComment: comments.isBlockComment,
    handleComments: {
      ownLine: comments.handleOwnLineComment,
      endOfLine: comments.handleEndOfLineComment,
      remaining: comments.handleRemainingComment
    },
    willPrintOwnComments: function willPrintOwnComments(path) {
      var node = path.getValue();
      return node && node.kind === "noop";
    },
    printComment: function printComment(commentPath) {
      var comment = commentPath.getValue();

      switch (comment.kind) {
        case "commentblock":
          {
            // for now, don't touch single line block comments
            if (!comment.value.includes("\n")) {
              return comment.value;
            }

            var lines = comment.value.split("\n"); // if this is a block comment, handle indentation

            if (lines.slice(1, lines.length - 1).every(function (line) {
              return line.trim()[0] === "*";
            })) {
              return join(hardline, lines.map(function (line, index) {
                return (index > 0 ? " " : "") + (index < lines.length - 1 ? line.trim() : line.trimLeft());
              }));
            } // otherwise we can't be sure about indentation, so just print as is


            return comment.value;
          }

        case "commentline":
          {
            return comment.value.trimRight();
          }

        /* istanbul ignore next */

        default:
          throw new Error("Not a comment: ".concat(JSON.stringify(comment)));
      }
    },
    hasPrettierIgnore: function hasPrettierIgnore(path) {
      var isSimpleIgnore = function isSimpleIgnore(comment) {
        return comment.value.includes("prettier-ignore") && !comment.value.includes("prettier-ignore-start") && !comment.value.includes("prettier-ignore-end");
      };

      var parentNode = path.getParentNode();
      var node = path.getNode();
      return node && node.kind !== "classconstant" && node.comments && node.comments.length > 0 && node.comments.some(isSimpleIgnore) || // For proper formatting, the classconstant ignore formatting should
      // run on the "constant" child
      node && node.kind === "constant" && parentNode && parentNode.kind === "classconstant" && parentNode.comments && parentNode.comments.length > 0 && parentNode.comments.some(isSimpleIgnore);
    }
  }
};
module.exports = {
  languages: languages,
  printers: printers,
  parsers: parsers,
  options: options,
  defaultOptions: {
    tabWidth: 4
  }
};