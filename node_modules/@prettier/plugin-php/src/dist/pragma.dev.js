"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var parse = require("./parser");

var memoize = require("mem");

var reHasPragma = /@prettier|@format/;
var getPageLevelDocBlock = memoize(function (text) {
  var parsed = parse(text);

  var _parsed$children = _slicedToArray(parsed.children, 1),
      firstChild = _parsed$children[0];

  var _parsed$comments$filt = parsed.comments.filter(function (el) {
    return el.kind === "commentblock";
  }),
      _parsed$comments$filt2 = _slicedToArray(_parsed$comments$filt, 1),
      firstDocBlock = _parsed$comments$filt2[0];

  if (firstChild && firstDocBlock && firstDocBlock.loc.start.line < firstChild.loc.start.line) {
    return firstDocBlock;
  }
});

function hasPragma(text) {
  // fast path optimization - check if the pragma shows up in the file at all
  if (!reHasPragma.test(text)) {
    return false;
  }

  var pageLevelDocBlock = getPageLevelDocBlock(text);

  if (pageLevelDocBlock) {
    var value = pageLevelDocBlock.value;
    return reHasPragma.test(value);
  }

  return false;
}

function injectPragma(docblock) {
  var lines = docblock.split("\n");

  if (lines.length === 1) {
    // normalize to multiline for simplicity
    var _$exec = /\/*\*\*(.*)\*\//.exec(lines[0]),
        _$exec2 = _slicedToArray(_$exec, 2),
        line = _$exec2[1];

    lines = ["/**", " * ".concat(line.trim()), " */"];
  } // find the first @pragma
  // if there happens to be one on the opening line, just put it on the next line.


  var pragmaIndex = lines.findIndex(function (line) {
    return /@\S/.test(line);
  }) || 1; // not found => index == -1, which conveniently will splice 1 from the end.

  lines.splice(pragmaIndex, 0, " * @format");
  return lines.join("\n");
}

function insertPragma(text) {
  var pageLevelDocBlock = getPageLevelDocBlock(text);

  if (pageLevelDocBlock) {
    var _pageLevelDocBlock$lo = pageLevelDocBlock.loc,
        startOffset = _pageLevelDocBlock$lo.start.offset,
        endOffset = _pageLevelDocBlock$lo.end.offset;
    var before = text.substring(0, startOffset);

    var _after = text.substring(endOffset);

    return "".concat(before).concat(injectPragma(pageLevelDocBlock.value, text)).concat(_after);
  }

  var openTag = "<?php";

  if (!text.startsWith(openTag)) {
    // bail out
    return text;
  }

  var splitAt = openTag.length;
  var phpTag = text.substring(0, splitAt);
  var after = text.substring(splitAt);
  return "".concat(phpTag, "\n/** \n * @format \n */\n").concat(after);
}

module.exports = {
  hasPragma: hasPragma,
  insertPragma: insertPragma
};